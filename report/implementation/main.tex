\section{Implementation} \label{impl}

In this section, to avoid hazy reference to `the implementation' or `our solution', and the name going unexplained in code listings, the working name \emph{tapioca}\footnote{TAPIOCA: Typed APIs that Ollie Coshed into an Acronym.} is used to refer to the library of that ilk~\cite{tapioca} which embodies the implementation of this project.

\input{implementation/proposal}

\subsection{Invocation} \label{impl:invocation}

In order for the programmer using \emph{tapioca} to be able to interact with multiple APIs in the same crate, it is necessary for each invocation of the \mintinline{rust}{infer_api!} macro to generate the Rust interface inside a unique module. For transparency, and to aid productivity through auto-complete and other tooling, \mintinline{rust}{infer_api!} requires this module name as an argument - in addition to a string containing a URL at which to find the associated schema - as shown in \cref{code:impl:invocation}.

\begin{codelisting}{code:impl:invocation}{Example setup for tapioca use}
\begin{minted}[tabsize=4]{rust}
    extern crate tapioca;
    const UBER_API_SCHEMA: &'static str = // ...
    
    tapioca::infer_api!(uber, UBER_API_SCHEMA);
    // after the macro returns, 'uber' is a module in this crate
    use uber;
    
    fn main() {
        // ...
    }
\end{minted}
\end{codelisting}

The macro then downloads the schema file, and caches it locally. This method of obtaining the schema was a design decision made to reflect that the adherence of client software's API usage to the schema is intended to be adherence to the API offered by the server. Thus, the schema should not be a file created by the user - it should be one provided by the provider of the API that he wishes to use.

\subsection{Inference} \label{impl:inference}

\subsection{User code} \label{impl:user-code}

\subsection{Lint pass} \label{impl:lint}

\subsection{Testing} \label{impl:testing}

A suite of sample schemata is used in integration testing, against which we try to compile test cases of both the `should compile' and `should fail to compile' varieties. This provides not only a benchmark for identifying regression, but also tracking of implemented features.

A successful test is one that either:
\begin{enumerate}[(a)]
	\item Contains a sample program exhibiting \emph{correct} API use, and compilation \emph{succeeds};
	\item Contains a sample program that attempts to use an API in a manner \emph{not} permitted by the schema, and compilation \emph{fails}.
\end{enumerate}

Fuzzing is used in order to prevent `over-fitting' to the test cases.

!TODO: much more.

\subsection{Error reporting} \label{impl:reporting}

In the event of type errors in the single use of an API in user code, the error is ultimately and detected by the built-in mechanisms. Since the query parameters, path arguments, et al. are each standard Rust types, the compiler type-checks the arguments to a \emph{tapioca} request as it does any other function: \mintinline{rust}{infer_api!} essentially translates the semantics of an OAS schema to Rust, and allows the compiler to handle the rest.

\Cref{code:impl:reporting:type-err} gives an example of the compiler reporting on erroneous use of a \emph{tapioca}-inferred API.

\begin{codelisting}{code:impl:reporting:type-err}{Example of an error being reported from an invalid type used in an API request}
\begin{minted}[tabsize=4]{rust}
// excerpt from examples/uber-error.rs
    use uber::products;
    
    let query = products::get::QueryParams {
        latitude: "10.3",
        longitude: 237.8,
    };
    products::get(query)?;
// end excerpt
\end{minted}
\begin{minted}[tabsize=4]{sh}
    $ cargo run --example uber-error
    error[E0308]: mismatched types
      --> examples/uber-error.rs:14:19
       |
    14 |         latitude: "10.3",
       |                   ^^^^^^ expected f64, found reference
       |
       = note: expected type `f64`
                  found type `&'static str`
\end{minted}
\end{codelisting}

Issues identified during the lint pass, pertaining to violation of a required ordering, or requests missing altogether, are emitted as a compiler warning via the plugin interface. \cfref{bg:rust:plugins}

\Cref{code:impl:reporting:lint} shows a user program that erroneously attempts to create a resource prior to one on which it depends.

\begin{codelisting}{code:impl:reporting:lint}{Example of lint warning of creating dependant before dependency resource}
\begin{minted}[tabsize=4]{rust}
// !TODO
\end{minted}
\begin{minted}[tabsize=4]{sh}
\end{minted}
\end{codelisting}

Warnings were chosen rather than (compilation-failing) errors in recognition that the programmer may know something about the state of the server resources that the lint pass cannot, and choose to ignore it. If such is the case, Rust allows him to then annotate the offending call with \mintinline{rust}{#[allow(LINT_NAME)]} in order to silence that particular instance of the warning in future compilations.
